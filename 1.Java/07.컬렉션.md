# 1. 컬렉션 프레임워크
컬렉션 프레임워크란, 데이터 군을 저장하는 클래스들을 표준화한 설계를 뜻한다. 
```
Collection Framework = Collection(다수의 데이터) + Framework(표준화된 프로그래밍 방식) 
```
## 1.1. 컬렉션 프레임워크의 핵심 인터페이스
컬렉션 프레임워크에는 컬렉션 데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다. 그리고 인터페이스 List 와 Set 의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였다. 여기서 List 와 Set 은 공통 부분이 많아 Collection 인터페이스로 뽑아내어 정의할 수 있었지만, Map 인터페이스는 이들과는 다른 형태로 컬렉션을 이루기에 같은 상속계층도에 포함되지 못했다.
[1. 그림이 들어가야합니다.]

### 1) 컬렉션 인터페이스별 특징
``` 
List : 순서가 있는 데이터 집합, 데이터의 중복을 허용한다.

Set  : 순서를 유지하지 않는 데이터 집합, 데이터의 중복을 허용하지 않는다.

Map  : Key 와 Value 로 이뤄진 데이터 집합, 순서는 유지되지 않는다. 키는 중복을 허용하지 않고 값은 중복을 허용한다.
```

### 2) 컬렉션 사용시 유의사항
객체 중 Vector, Stack, Hashtable, Properties 와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 전부터 존재하였다. 따라서 컬렉션 프로엠워크 명명법을 따르지 않는다. Vector 나 Hashtable 과 같은 기존의 컬렉션 클래스들은 호환을 위해 남겨두었지만, 가능하면 사용을 지양하는 것이 좋다. **대신 ArrayList 나 HashMap 을 사용하도록하자.**

#### 1) ArrayList 
ArrayList 는 컬렉션 프레임워크에서 가장 많이 사용되는 컬렉션 클래스이다. ArrayList 는 List 인터페이스를 구현하기 때문에 데이터 저장순서가 유지되고 중복을 허용하기 때문이다. 또한 Object 배열을 이용하여 데이터를 순차적으로 저장하기 때문에 모든 종류의 객체를 담을 수 있다.

##### ArrayList 의 remove(int index) 메서드
아래는 ArrayList의 remove 메서드를 사용하여 list1과 list2의 공통되는 요소들을 찾아서 삭제하는 예시를 나타낸다.
```java
/** 서로 다른 2개의 ArrayList 내 공통 되는 값 제거하는 메서드 예시 **/
for(int i = list2.size() - 1; i >= 0; i--) {
  if(lsit1.contains(list2.get(i)) {
    list2.remove(i);
  }
}
```
이 때, i의 인덱스를 0부터 시작하여 증가시켜간 것이 아닌 size()-1부터 시작하여 감소해 나아가도록 구현한 것을 알 수 있다. 만약 인덱스 i를 증가시켜가면서 삭제하면, 한 요소가 삭제됨으로써 나머지 요소들이 자리이동을 하고, 이는 의도하지 않은 인덱스의 처리를 발생시키기 때문이다. 따라서 remove(int index) 메서드 사용시에는 맨 뒤부터 다른 요소들의 자리 이동없이 삭제되도록 구현하여야 한다. 

아래는 remove(int index) 메서드의 구현 소스 코드이다.
```java
/** ArrayList 내 remove(int index) 메서드 구현 소스 코드 **/
public Object remove(int index) {
  Object oldObj = null;
  if(index < 0 || index >= size) {
    throw new IndexOutOfBoundsException("범위를 벗어났습니다.");
  }
  oldObj = data[index];
  if(index != size - 1) {
    System.arraycopy(data, index+1, data, index, size-index-1);
  }
  data[size-1] = null;
  size--;
  
  return oldObj;
}
```
위에서 보았듯이, remove 메서드는 지정된 위치에 있는 객체를 삭제하고 삭제한 객체를 반환하도록 작성되었다. 삭제할 객체의 바로 아래에 있는 데이터를 한 칸씩 위로 복사하여 삭제할 객체를 덮어쓰는 방식으로 처리한다. 만약 삭제할 객체가 마지막 데이터라면 복사는 이뤄지지 않고 단순히 null로만 변경된다.
[2. 그림이 들어가야합니다.]

#### 2) LinkedList
배열(ArrayList)의 장단점은 아래와 같다.
- 배열은 가장 기본적인 형태의 자료구조 이며, 사용하고 쉽고 데이터를 읽어오는데 걸리는 시간이 가장 빠르다는 장점을 가지고 있다. 
- 배열은 크기를 변경할 수 없고, 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다는 단점이 있다.
이러한 배열의 단점을 보완하기 위해서 LinkedList 라는 자료구조가 고안되었다. 배열은 모든 데이터가 연속적으로 이뤄져 있지만, 링크드 리스트는 아래와 같이 불연속적인 데이터가 서로 연결된 형태로 구성 되어 있다.
[3. 그림이 들어가야합니다]

위 그림과 같이 LinkedList 는 데이터 뿐만 아니라 다음 요소의 주소를 저장하는 공간도 따로 마련되어 있음을 알 수 있다. 따라서 중간의 어떠한 데이터를 삭제할 때, 배열처럼 for 문을 돌면서 데이터를 삭제할 필요없이, 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 바라보게 하면된다. 새로운 데이터를 중간에 넣을 때도 마찬가지이며, 이를 통하여 삭제 및 추가에 대한 처리가 배열보다 빠르다. 그러나 LinkedList 는 단방향이므로 다음 요소에 대한 접근은 쉽지만, 이전 요소에 대한 접근은 어렵다. 
LinkedList 의 장담점은 아래와 같다.
- ArrayList와 달리 다음 노드에 대한 주소값이 함께 저장되어 있으므로, 배열 중간의 삭제 및 삽입의 처리 속도가 빠르다.
- 다음 노드의 주소만 가진 단방향의 이동 방향을 가지기 때문에, 이전 노드에 대하여 접근하기 어렵다.



















