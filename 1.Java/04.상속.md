# 4. 상속

## 4-1. 상속의 개념
- 상속이란, 부모 클래스로부터 자식 클래스가 부모의 멤버 변수, 메서드 등을 사용할 수 있도록 하는 것을 의미한다.
- 이미 잘 짜여진 클래스 코드를 그대로 이용할 수 있으므로 코드의 재사용성을 높힐 수 있으며, 중복을 줄일 수 있다.

## 4-2. 상속의 용어
- 부모 클래스를 상위 클래스 혹은 슈퍼클래스라고 한다. "부모 클래스가 자식 클래스에게 상속한다" 라고 말할 수 있다.
- 자식 클래스를 하위 클래스라고 한다. "자식 클래스가 부모 클래스에게 상속받는다" 라고 말할 수 있다.
- 상속을 사용하기 위해선 extends 예약어를 사용한다. 
- 아래의 코드와 같이 간단하게 부모 클래스 A로부터 상속받는 자식 클래스 B를 생성할 수 있다.
``` java
class B extends A {
  //TODO 
}
```

## 4-3. 상속의 특징
- 상속 관계에서는 상위 클래스가 하위 클래스보다 일반적인 개념이고, 하위 클래스는 상위 클래스보다 구체적인 클래스가 된다.
- 자식 클래스는 부모 클래스의 변수와 메소드를 상속받아 사용할 수 있다.
- 부모 클래스는 자식 클래스에서 구현한 변수 및 메소드를 상속받아 사용할 수 "없"다.
- 하위 클래스가 생성될 때는 반드시 상위 클래스의 생성자가 먼저 호출되고 그 다음에 하위 클래스의 생성자가 호출된다.
 
## 4-4. super 예약어
- 하위 클래스가 생성될 때 상위 클래스의 생성자가 생성될 수 있는 이유는 super 예약어 덕분이다.

  1. 다음은 어떠한 하위 클래스(자식 클래스) 생성자의 예시 코드 이다.  
  ``` java
  public VIPCustomer() {
    customerGrade = "VIP";
    bonusRatio = "0.05";
    discountRatio = "0.01";
    System.out.println("자식 클래스 생성자 호출");
  }
  ```

  2. 해당 자식 클래스의 생성자가 바이트 코드로 변환되기 전에 다음과 같이 코드가 변경된다.
  ``` java
  public VIPCustomer() {
    /** 아래의 한 줄이 자동으로 추가됨 **/
    super();
    customerGrade = "VIP";
    bonusRatio = "0.05";
    discountRatio = "0.01";
    System.out.println("자식 클래스 생성자 호출");
  }
  ```

  3. 이를 통하여 하위 클래스의 생성자가 호출될 때, 상위 클래스의 생성자가 먼저 호출될 수 있다.

- 이렇듯, 자식 클래스에서의 super() 호출은 부모 클래스의 생성자를 의미한다.
- 부모 클래스에서 선언한 멤버 변수 혹은 메서드를 이용할 때도 super 예약어를 이용할 수 있다. (ex. super.methodName)
- 이는 클래스에서 자기 자신의 멤버 변수 혹은 메서드를 이용할 때 사용하는 this 와 같은 맥락으로 볼 수 있다. (ex. this.methodName)

## 4-5. 상위 클래스로의 묵시적 클래스 변환
- 부모 클래스(A)로부터 상속받은 자식 클래스(B)는 A 클래스이면서 동시에 B 클래스이다.
- 따라서 아래와 같이 클래스 형을 변환하여 선언할 수 있다.
``` java
A object = new B();
```
- 그러나 아래와 같이 부모 클래스는 클래스 형을 변환하여 선언할 수 없다.
``` java
B object = new A();
```
- 클래스 형을 변환하여 선언한 인스턴스는 자식의 멤버 변수 및 메서드를 사용할 수 없다.
- 클래스가 형 변환이 되었을 때는 선언한 클래스형에 기반하여 멤버 변수와 메서드에 접근하기 때문이다.
- 이는 다형성을 다룰 때 중요하므로, 잘 숙지하도록 한다.

## 4-6. 매서드 오버라이딩
- 상위 클래스에서 상속받은 하위 클래스는 자신만의 멤버변수와 메서드를 가질 수 있다.
- 그러나 자식 클래스에서는 부모 클래스의 메서드 그대로 쓰지 않는다.
- 즉, 메서드의 재정의가 필요하다. 이를 메서드 오버라이딩(Override) 이라고 한다.
- 이를 위해서는 기존 부모 클래스의 메서드와 "반환형, 메서드 이름, 매개변수 개수, 매개변수 자료형"이 반드시 같아야 한다.
- 오버라이딩을 구현하기 위해서는 오버라이딩 어노테이션을 이용한다. (@Override)

## 4-7. 가상 메서드
- 상위 클래스에서 선언한 메서드가 있고, 이 메서드를 하위 클래스에서 재정의한 상태라고 가정하자.
- 이 때, 4-5 와 같이 묵시적 클래스 변환을 이용한다면, 어떻게 될까?
``` java
/** A 의 메서드 **/
public void testMethod() {
  System.out.println("Class A's Method");
}

/** B 의 메서드 **/
@Override
public void testMethod() {
  System.out.println("Class B's Method");
}

/** 메서드 호출 **/
A object = new B();
object.testMethod();
```

- A의 메서드가 아닌 B의 메서드가 호출되어 나타난다.
```
/** 호출 결과 **/
Class B's Method
```

- 이렇듯 재정의한 상태에서 하위 클래스가 상위 클래스로 형 변환되고, 이 때 재정의한 메서드가 호출된다면, 사용한 자료형(A)의 메서드가 호출되는 것이 아닌 생성된 인스턴스(B)의 메서드가 호출된다. 이를 가상 메서드라고 하며, 자바의 모든 메서드는 가상 메서드이다.

## 4-8. 인터페이스 상속
- 인터페이스를 상속 받는 하위 클래스는 여러 개의 상위 클래스를 상속받을 수 있다.
- 이 때는 extends 가 아닌 implements 예약어를 사용한다.
- 인터페이스를 상속 받은 하위 클래스는 상위 클래스에서 정의된 모든 메서드에 대하여 재정의(Override)되어야 한다.
``` java
public class ChildClass implements Interface1, Interface2, ... { ... }
```
